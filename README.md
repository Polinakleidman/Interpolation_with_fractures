# Интерполяция параметров скважин с учетом разломов земной коры
## Описание проблемы:
Известно, что многие параметры земной коры в различных точках (такие как глубина пластов, …) можно узнать, зная эти же параметры в каких-то определенных пробуренных скважинах, учитывая лишь расстояния до известных скважин. Основная проблема поиска таких параметров заключается в том, что такая зависимость пропадает, если путь до известной скважины проходит через разлом земной коры. Чтобы это исправить, нужно искать кратчайший путь, не проходящий через разломы. 

## Постановка задачи:
### Дается:
* прямоугольная сетка плоскости, в узлах которой нужно найти какой-то параметр(например нефтенасыщенность)
* описание разломов (наборы полигонов, которые представляют собой ломанные)
* координаты и параметры пробуренных скважин (они не обязательно находятся в узлах сетки)
### Вывод:
* значение параметров в каждом узле сетки

## Решение:
 *Замечание: Если считать, что сетка достаточно плотная, то можно вместо евклидового расстояния использовать манхэттенскую метрику или метрику Чебышева (в своем решении я использовала манхэттенскую, (с метрикой чебышева количество ребер увеличится примерно в 2 раза)*
* Для начала опишем граф обхода:
  * обозначим xleft, ybottom – координаты левого нижнего угла сетки
  * dx, dy - шаг сетки по оси x и по оси y	
  * nx,ny – количество узлов по х и по y (то есть всего узлов будет nx*ny, а ширина сетки=(nx – 1)*dx, длина=(ny – 1)*dy
  * Data – массив пробуренных скважин, count_data = их количество
  * Faults – разломы (то есть массив ломанных) </br>

Тогда в нашем графе **вершинами** будут узлы сетки и пробуренные скважины (их nx * ny + count_data) 
* Если вершина – известная скважина, то из нее максимум выходит 4 ребра в 4 узла, ее окружающие ( если через эту клетку проходит разлом, то в отсеченные вершины ребра не проводим)
* Если вершина – узел, то ребра до скважин в квадрате окрестностью [x -dx, d+dx] * [y -dy, d+dy] уже проведены, и мы проводим еще максимум 4 ребра до ближайших узлов (аналогично предыдущему случаю если эти ребра пересекаются с полигонами(частями разломов), то их мы не проводим.

  *Заметим что непосредственных ребер между двумя скважинами никогда не проводятся, но так и должно быть, потому что скважины в одной клетке можно просто усреднить и считать, что в каждой клетке максимум одна скважина)*

Теперь граф построен, на каждом **ребре** написан его вес (манхэттенская длина), запустим тогда Дейкстру от каждой скважины

#### Посчитаем асимптотику: 
Построение графа работает за O(n+m) = (nx * ny+ count_data + 4 * (nx * ny+count_data) =O(nx * ny+count_data)
дейкстра  O(mlogn) = O(nlogn)
так как практически всегда nx * ny < 1000 * 1000, count_data < 1000, то итоговое время < O(10^9 * log(10^9)) ~ несколько минут

### Теперь перейдем к интерполяции.
*В качестве примера будем рассматривать параметр - глубина верхнего края нужного пласта*
* Рассмотрим построение изолиний по полученным глубинам в узлах сетки
* **Photo 1**
  ![Photo 1](https://github.com/Polinakleidman/Interpolation_with_fractures/blob/main/1.jpg "")
  * Первый график – как выглядела бы карта верхней границы пласта, если бы не было разломов (сами разломы отображены красным цветом) Видно, что все изолинии плавные, хотелось бы добиться, чтобы они сохраняли такое свойство и при учете разломов
  * Рассмотрим вторую и третью картинку. Видно, что в обоих вариантах образуются “зубчики”, но в варианте **2b** их в целом меньше и картинка выглядит более гладкой.
  * **Photo 2a**
  ![Photo 2](https://github.com/Polinakleidman/Interpolation_with_fractures/blob/main/2.jpg "") 
  * **Photo 2b**
  ![Photo 3](https://github.com/Polinakleidman/Interpolation_with_fractures/blob/main/3.jpg "")
  * Причины: 
    1. возможно так происходит из-за взятия манхэттенской метрики вместо евклидовой, но взятие евклидовой невозможно, так как непонятно, как строить граф с такой метрикой(должно быть счетное число вершин) 
    2. Вторая и более значимая причина – выбор степени (power) в формуле для интреполяции: 
    ```
      h = sqrt(dxn * dxn + dyn * dyn + asmoosnes * asmoosnes);
      ph = 1 / pow(h , power); 
    ``` 
      Видно, что во втором случае, когда power=2, изолинии более гладкие, но к сожалению, все еще требуются улучшения. 
